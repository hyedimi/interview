# interview
자바 개발자가 인터뷰 전 알고가면 좋을 내용  

---

> ## 목차

<br>

**🟣 자바 프로그래밍**

1. [객체지향 프로그래밍](#객체지향-프로그래밍)
2. [클래스와 객체](#클래스와-객체)
3. [생성자](#생성자)
4. [추상화](#추상화)
5. [캡슐화](#캡슐화)
6. [상속](#상속)
7. [다형성](#다형성)
8. [추상클래스와 인터페이스](#추상클래스와-인터페이스)
9. [Static](#static)
10. [접근제어자 public, protected, default, private](#접근제어자)
11. [오버로딩과 오버라이딩](#오버로딩과-오버라이딩)
12. [바인딩](#바인딩)
13. [SOLID 원칙 이해](#solid-원칙-이해)
14. [Wrapper Class](#wrapper-class)
15. [Collection과 Map](#collection과-map)


**🟣 WEB**

1. [웹서버와 WAS](#웹서버와-was)
2. [DOM과 Virtual DOM](#dom과-virtual-dom)
3. [SEO란](#seo란)
4. [CSR과 SSR](#csr과-ssr)
5. [SPA](#spa)
6. [캐시 쿠키 세션](#캐시-쿠키-세션)
7. [웹스토리지](#웹스토리지)
8. [모듈 웹팩](#모듈-웹팩)
9. [MVC](#mvc)
10. [PWA](#pwa)
11. [네이티브앱 웹앱 하이브리드앱 크로스플랫폼](#네이티브앱-웹앱-하이브리드앱-크로스플랫폼)

**🟣 통신**

1. [CORS](#cors)
2. [REST API](#rest-api)
3. [SOAP](#soap)


**🟣 클라우드/데브옵스**

1. [도커](#도커)
2. [쿠버네티스](#쿠버네티스)
3. [CI CD](#ci-cd)
4. [CDN](#cdn)
5. [클라우드 서비스 모델 - Iaas, Paas, Saas](#클라우드-서비스-모델)

**🟣 운영체제와 시스템**

1. [프로세스 스레드](#프로세스-스레드)
2. [XSS와 CSRF](#xss와-csrf)
3. [IDS IPS WAF](#ids-ips-waf)
4. [프록시 서버](#프록시-서버)
5. [OAuth 2.0](#oauth)
6. [암호화 복호화](#암호화-복호화)

**🟣 프로그래밍**

1. [디자인패턴](#디자인패턴)
2. [TDD](#tdd)
3. [RPA](#rpa)
4. [애자일 방법론](#애자일-방법론)
5. [스택과 큐](#스택과-큐)
6. [예외처리](#예외처리)

**🟣 JPA**

**🟣 DATABASE**

1. [스키마](#스키마)
2. [인덱스](#인덱스)
3. [IDENTITY](#identity)
4. [샤딩](#샤딩)
5. [ERD와 UML](#erd와-uml)
6. [데이터 마이닝](#데이터-마이닝)
7. [해시](#해시)
8. [데이터 무결성](#데이터-무결성)
9. [프로시저](#프로시저)
10. [사용자 정의 함수](#사용자-정의-함수)
11. [트리거](#트리거)
12. [커서](#커서)
13. [OFFSET FETCH](#offset-fetch)
14. [트랜젝션](#트랜젝션)

**🟣 기타 개발 상식**

1. [ERP](#erp)

<br>

---

<!------------------------객체지향 프로그래밍---------------------->

# 🟣 객체지향 프로그래밍

## 객체지향 프로그래밍

🔹 **객체지향의 구성요소** : 클래스, 객체, 메소드  
🔹 **객체지향의 3대 특징** : 캡슐화, 상속, 다형성  

- 부모 클래스에 공통 코드를 모아 유지 보수성을 높임
- 클래스간의 의존도와 결합도를 낮춤
- 코드의 재활용성이 높다.

## 클래스와 객체

🔹 **클래스**  
 - 객체를 만들기 위한 설계도, 템플릿
 - 속성과 행위를 정의
 - 메모리의 힙 영역을 소모하지 않음
 - 클래스는 여러번 인스턴스화 가능
 - 각기 다른 접근 제어자 및 가시성 범위를 가진다.
 - abstract, final, private 선언 가능  
 
🔹 **객체**  
 - 클래스의 인스턴스
 - 상태(필드)와 동작(메서드)를 가진다.
 - 실제로 메모리상에 할당 (new 키워드를 통해 생성)
 - 접근제어자 및 가시성 범위를 가진다.
 - 가변, 불변 속성을 가진다.
 - 가비지 컬렉터를 통해 수집된다.  

## 생성자

**생성자의 역할** : 객체화 될 때 필드를 초기화 하는 역할  

 - 모든 클래스는 인스턴스화 될 때 생성자를 사용한다.
 - public 클래스명(매개변수..) { ... }
 - 리턴타입이 명시되어있지 않다.
 - 매개변수가 없는 생성자는 기본생성자이다.
 - 생성자를 만들지 않으면 컴파일시 자동으로 생성된다.
 - 개발자가 생성자를 만든다면 기본 생성자는 자동으로 만들어지지 않는다.

## 추상화

- 사용자에게 높은 수준의 작업집합만 노출하고 내부 구현은 숨긴다.
- 추상화를 통해 수행방법이 아닌 수행하는 일 자체에 집중시킨다.
- 인터페이스와 추상 클래스를 통해 

ex) interface에 정의된 동작을 implements한 후 상세내용을 구현할 경우, 상세 구현한 class의 내용은 사용자는 몰라도 public 메서드에 접근할 수 있다.

## 캡슐화

 - 객체 상태가 외부로부터 숨겨진 상태에서 일련의 공개(public) 메서드만 노출하는 기법
 - 각 객체가 클래스 내에서 객체 상태를 private로 유지될 때 성립
 - 느슨한 결합, 재사용성의 장점
 
```java

  public class Cat{
    private int hungry = 10;
    
    public void play(){
      hungry ++;
    }
    
    public int getHungry(){
      return hungry;
    }  
  }
```

## 상속
 
 - 다른 객체의 코드를 재사용하도록 허용
 - 각 객체만의 로직 추가 가능
 - IS-A관계 (고양이 IS-A 고양이과 동물, 기차 IS-A 교통수단)
 - extends 키워드 사용
 - 여러개의 클래스 상속 불가
 - 자식클래스는 부모의 필드와 메서드를 재사용 할 수 있음 (override)

## 다형성

 - 객체지향 프로그래밍의 핵심 개념 중 하나
 - 객체를 좀 더 다양하게 확장하여 표현 할 수 있다.
 - 대표적인 특징으로는 [메소드 오버라이딩과 메소드 오버로딩](#오버로딩과-오버라이딩)을 들 수 있다.


## 추상클래스와 인터페이스

🔹 **추상클래스**  
 
 - 생성자와 상태를 가질 수 있다.
 - abstract 키워드를 클래스에 추가하면 추상 클래스가 된다.
 - 추상클래스는 확장을 통해서만 사용이 가능하다 (final 사용 불가)
 - 추상 메서드가 없어도 문제가 없다.
 
🔹 **인터페이스**  

 - 구현시 어떻게 동작할지 명시하도록 설계
 - 자바 8 이전까지 인터페이스 안에 abstract가 아닌 메서드를 사용할 수 없었다.
 - default, static 키워드를 통해서 인터페이스에 추가 기능을 더할 수 있다.
 - default 메서드를 오버라이드하거나 암묵적 구현이 가능.
 - static 메서드는 오버라이드 할 수 없다. (인터페이스명과 메서드이름을 통해 접근가능 -> Vehicle.description(); )
 - default 메서드만 가지는 것은 안티패턴임으로 인터페이스의 목적에 벗어남

**❔ 추상 클래스와 인터페이스의 주요 차이점은?**

인터페이스가 생성자를 지원하지 않는 반면 추상 클래스는 생성자를 가질 수 있다.  
따라서 추상 클래스는 상태를 가질 수 있지만 인터페이스는 상태를 가질 수 없다.  
인터페이스의 주요 목적은 완전히 추상화된 상태를 구현하는 것이지만, 추상 클래스는 부분적인 추상화를 위한 것이다.  

**❔ 추상 클래스이면서 동시에 final인 클래스를 만들 수 있는가?**

 final 클래스는 서브클래스화 되거나 상속할 수 없다.  
 추상 클래스는 확장을 통해서만 사용할 수 있기 때문에 이 두 가지를 동시에 적용할 수 없다.  
 컴파일러에서 오류가 발생한다.  
 
## Static

- class가 인스턴스화 하지 않아도 사용할 수 있다.
- static 변수는 값을 공유한다. 값을 저장할 수 있는 공간이 하나만 생성된다.
- static 메소드 안에서 static화 되지 않은 변수나 함수는 사용할 수 없다.

## 접근제어자

- public : 모든 접근을 허용
- protected : 같은 패키지 접근 허용 / 패키지가 다르지만 상속을 받은 경우 접근 허용
- default : 접근지정자 / 같은 패키지 내에서 접근 허용
- private : 자기 자신만 접근 가능

public > protected > default > private

## 오버로딩과 오버라이딩

**다형성의 대표적인 특징**

🔹 **오버로딩**  

 - 동일한 메서드 이름을 가지고 있지만 매개변수의 유형과 개수를 다르게 하여 메소드를 여러개 정의하는 것
 - 매개변수가 다른 경우 컴파일러가 식별할 수 있다. '컴파일 타임 다형성'
 - static, final, private 메서드를 오버로드 할 수 있다.
 - 정적 바인딩

🔹 **오버라이딩**  

 - 부모클래스의 메소드와 똑같은 모양(메소드 명, 매개변수 개수, 리턴타입 등..)의 메소드를 자식 클래스에서 재정의하는 것
 - 런타임시 자바가 클래스 구별 가능하다. '런타임 다형성'
 - 자식클래스에서 정의된 메소드가 호출 되며, 부모의 메서드를 부를 때는 super.메소드명(); 으로 부른다.
 - @override 어노테이션 사용
 - 메서드는 satic, final, private가 아니어야함
 - 오버라이딩 된 메서드는 확인된 예외보다 넓은 범위의 예외는 발생시킬 수 없다.
 - 동적 바인딩
 
## 바인딩

 - 메서드 호출시 메서드 본문에 연결하는 과정
 - 정적 바인딩 작업 : 컴파일 타임 바인딩
 - 동적 바인딩 작업 : 런타임 바인딩
 - 정적 바인딩은 컴파일 시간 성능에 오버헤드를 더하고, 동적 바인딩은 런타임 성능에 오버헤드를 

## SOLID 원칙 이해


(...ing)


## Wrapper Class

 - Boolean, Byte, Short, Integer, Long, Float, Double 클래스
 - 기본형 타입을 객체(클래스, 객체형, 참조형)로 변환시킬때 사용하는 클래스

  ```java
  int i = 5;  // 기본형 타입
  Integer i2 = new Integer(5);
  ```

 ◽ **오토박싱**  
 기본형 타입의 데이터를 객체 타입 데이터로 자동 형변환
 
 ```java
  Integer i3 = 5; // 문제없이 작동
 ```
 
 ◽ **오토 언박싱**  
 객체 타입의 데이터를 기본형 타입 데이터로 자동 형변환
 
 ```java
  int i4 = i3.intValue(); // 객체 -> int로 변경
  int i5 = i3; // java 5부터 바로 꺼내서 사용 가능 
 ```
 
## Collection과 Map

Java의 자료구조는 Collection과 Map으로 나눌 수 있다.

🔹 Collection 인터페이스를 상속받는 List와 Set이 있다.

🔹 Map은 Key, Value의 구조를 가지며, 독립적인 인터페이스가 구현되어 있다.

  ### List 
  
   - 리스트는 순서를 가진다.
   - 원소의 중복이 허용 된다.
   - **ArrayList** : 단방향 포인터. 조회가 많은 경우 사용.
   - **LinkedList** : 양방향 포인터. 삽입/삭제가 많은 경우 사용.
   - **Vector** : Thread-Safe하여 동기화를 지원함. 멀티 스레드 환경에서 사용하기 좋다. lock이 걸림
  
  ### Set
  
   - 순서가 없다.
   - 원소의 중복을 허용하지 않는다.   
   - **HashSet** : 대표적인 Set 자료구조
   - **LinkedHashSet** : 순서를 가진다.
   - **TreeSet** : 순서가 없고 중복을 허용하지 않지만, 데이터를 정렬하여 저장


  ### Map

   - 키와 값의 쌍으로 이루어진 데이터 집합
   - 순서가 유지되지 않음
   - 키는 중복을 허용하지 않음   
   - **HashMap** : 대표적인 Map 자료구조. null 가능
   - **LinkedHashMap** : 순서를 가진다.
   - **HashTable** : Thread-Safe하여 동기화를 지원한다.
   - **TreeMap** : 중복을 허용하지 않음, 순서를 가진다. 데이터를 정렬하여 저장.

<br>

---

# 🟣 WEB

## 웹서버와 WAS

**웹서버와 was의 동작 방식**

1. 웹 서버는 클라이언트에서 요청한 http 메시지를 확인한 뒤 응답한다. 이때 정적인 페이지는 웹서버에서 처리한다.
2. 동적인 내용이 필요하면 WAS(웹 컨테이너)로 작업을 넘긴다.
   - WAS는 Servlet을 메모리에 올리고 web.xml을 참조해 servlet에 대한 Thread를 생성한다.
   - httpServletRequest와 HttpServletResponse 객체를 생성하여 Servlet에 전달한다.
   - doGet() 또는 doPost() 메서드를 통하여 생성된 동적페이지를 Response 객체에 담아 WAS에 전달한다.
3. WAS는 Response 객체를 HttpResponse 형태로 바꾸어 웹 서버에 전달한다.
4. 생성된 Thread와 HttpServletRequset, HttpServletResponse 객체를 제거한다.

❔ **WAS에 웹서버가 존재하는데 따로 웹서버를 두는 이유는?**

 - 기능을 분리하여 서버 부하를 방지한다. WAS에서 정적 컨텐츠까지 처리한다면 부하가 커진다.
 - 하나의 웹서버와 여러대의 WAS를 연결 할 수 있다. (로드발랜싱)
 - 무중단 운영을 위한 장애 극복에 대응

## DOM과 Virtual DOM

🔹 **DOM** 
DOM은 HTML, XML 문서에 접근하기 위한 브라우저에 내장된 API이다.  
DOM을 사용하여 HTML의 항목을 생성, 변경, 수정, 삭제 할 수 있다.  
DOM은 HTML 문서를 읽어 웹 화면에 띄워 주는 역할을 한다.  
자바스크립트가 DOM API를 이용하여 HTML을 제어한다.  

🔹 **Virtual DOM**  
DOM 기반 시스템은 조작시마다 전체를 렌더링하기 때문에 비효율적이다.  
Virtual DOM을 이용하여 변경된 내용만 파악해 그 부분만 랜더링한다.  
대표 프레임워크 : 리액트, Vue.js, 앵귤러

## SEO란

**Search Engine Optimization 검색 엔진 최적화**  
웹 사이트가 검색 결과에 더 잘 노출되도록 최적화 하는 과정.  
'title' 태그, 'meta name=description' 태그 등 크롤러가 이해할 수 있는 웹 페이지 정보를 기록해야한다.

## CSR과 SSR

🔹 **CSR (Client Side Rendering)**  

초기 로딩시 서버에서 HTML, 자바스크립트 등의 파일을 받아오기 때문에 첫 페이지 로딩이 느리다.  
렌더링 속도가 빠르다. (초기 로딩 제외)  
SEO가 어렵다.  
서버 부담이 적다.  

🔹 **SSR (Server Side Rendering)**  

첫 페이지 로딩이 빠르다.  
SEO에 적합하다.  
화면 전환 시 깜빡임 문제가 있다.  
서버 부담이 크다.  
클릭해도 페이지가 반응하지 않는 문제가 있다.  

## SPA

CSR방식 단일 페이지로 만든 웹 사이트.
하나의 페이지 안에서 필요한 부분만 동적으로 처리하는 개발 방법.
SSR 방식과 비교했을 때 배포가 간단하다.

**SPA 프레임워크**
앵귤러 : 구글에서 만든 프레임워크, 타입스크립트 기반. 다른 프레임워크에 비해 무겁고 다루기 어렵다.
리액트 : 페이스북에서 만든 프레임워크, 자바스크립트, 타입스크립트를 기반.
뷰 : 개인 개발자가 만든 프레임워크로 앵귤러와 리액트의 장점을 수용했고, 코드가 깔끔하고 배우기 용이.

## 캐시 쿠키 세션

**❔ 쿠키와 세션을 이용하는 이유는?**

HTTP통신의 비연결성과 비상태성 특징으로 인하여 쿠키와 세션을 사용한다.  
비연결성은 클라이언트에게 요청을 받고 응답을 보낸 후 연결을 끊는 처리 방식이고, 비상태성은 클라이언트 상태 정보를 가지지 않는 서버 처리 방식이다. 따라서 그 다음 통신에서 이전 데이터를 유지하지 않는다.  

* 캐싱은 HTTP와 통신과 상관 없이 리소스를 저장하는 형태임.

|◽|캐시|쿠키|세션|
|---|---|---|---|
|저장위치|클라이언트(사용자PC)|클라이언트(사용자PC)|웹서버|
|저장형식|이미지, HTML, 파일 등|text|Object|
|데이터형식|파일|Key-value, String|{}|
|만료시점|유효기간 설정, 사용자 삭제시|유효기간 설정, 브라우저 종료시 유지|브라우저 종료시 삭제|
|용량제한|사용자PC 캐시용량 범위|도메인별 4,093 byte|서버허용용량 범위|
|속도|페이지의 리소스를 빠르게 가져옴|세션보다 빠름|쿠키보다 느림|
|보안|-|보안성이 낮음|보안성이 높음|

## 웹스토리지

클라이언트의 웹 브라우저 내에 데이터를 저장하는 방식  
key-value 형태  
쿠키의 여러 단점을 보완하고자 등장한 데이터 저장 기술  
저장 용량이 도메인별로 약 5MB  
예시 - 자동 로그인기능, 블로그의 글 임시저장, 장바구니 상품 목록 등

**🔹 로컬 스토리지**  
로컬 PC의 저장소, 로컬 스토리지에 저장한 데이터는 영구적으로 저장된다.  
탭을 닫더라도 유지되는 정보.  

**🔹 세션 스토리지**  
데이터의 영구 저장이 불가  
페이지의 세션이 끝나면 데이터가 자동 삭제  
브라우저 닫으면 삭제  
예시 - 입력 폼에 사용자가 직접 입력한 값, 이전 페이지의 스크롤 위치 등  

```javascript

localStorage.setItem("a", "abcd");
sessionStorage.setItem("a", "abcd");

localStorage.getItem("a");
sessionStorage.getItem("a");

localStorage.removeItem("a");
sessionStorage.removeItem("a");

localStorage.clear();
sessionStorage.clear();

```

## 모듈 웹팩

**🔹 모듈**  
가독성을 위해 분리된 파일 각각을 모듈이라 부른다.  
모듈은 그 자체로 완전히 독립적인 기능을 하기도 하고, 필요시에 참조하여 기능을 수행한다.  
모듈은 독립성이 높게 만들어 결합도를 낮춰야한다.  
export, import를 통하여 내보내고 불러온다.  

**🔹 웹팹**  
HTML, CSS, 자바스크립트, Image 등 웹 앱을 구성하는 자원을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만듬  
웹 자원들을 그룹화(번들링)하여 하나의 파일로 묶어서 서버 요청 횟수를 줄일 수 있다.  
웹팩의 주요 구성 요소 중 하나인 로더는 웹팩과 바벨을 연동 시키는 일을 한다.  
로더는 html, css, font 등의 파일을 자바스크립트로 변환하여 모듈로서의 역할을 한다.  

## MVC

소프트웨어 디자인 패턴 중 하나.  
대표적으로 스프링 프레임워크가 있다.  
Model(데이터영역) - View(뷰 영역) - Controller(비지니스 로직 처리 영역)  

**MVC에서 파생된 패턴**  
MVP(Model-View-Presenter)  
MVVM(Model-View-View Model)  

## PWA
Progressive Web App  
웹에서 네이티브 앱 수준의 사용자 경험을 제공하는 것이 목적  
모바일 웹 앱에 PWA를 도입하면 검색 엔진 최적화가 가능하다.  
스마트폰의 주소록, 카메라에 접근과 같은 네이티브 기능을 사용할 수 있다.  
iOS(애플)에서 푸시 알림 등 미지원  

일반적인 웹 앱을 PWA로 만들기 위해서는 3가지 요건을 충족해야 한다.  

1. 서비스 워커
  웹 브라우저 뒤편에 항상 실행되고 있는 백그라운드 프로그램  
  오프라인 상태에서도 항상 실행되고 있기 때문에 오프라인 동작을 설계할 수 있다.
2. 웹 앱 매니페스트
  앱 이름, 아이콘, 화면 방향, 배경 색 등 기본 정보 및 설정을 저장한 JSON 파일
3. HTTPS
  웹 서버와의 보안이 중요하기 때문에 HTTPS를 통해 배포되고 실행되어야한다.


## 네이티브앱 웹앱 하이브리드앱 크로스플랫폼

|◽|장점|단점|
|---|---|---|
|네이티브 앱|- 디바이스의 성능을 사용하여 빠르고 안정적<br>- 네이티브 전용 기능 (GPS, 자이로 센서, 얼굴인식 등)|- iOS, 안드로이드 각각 개발필요<br> - 느린 업데이트|
|웹 앱|- 개발 및 서비스가 간단하여 빠른 서비스 가능<br>- 다양한 플랫폼에 대응 가능|-크롬, 사파리 등 브라우저의 기능 만큼만 서비스<br>- 접속시마다 필요한 리소스를 다운로드<br>- 앱 스토어 출시 불가(PWA기능을 통해 안드로이드에 한해 앱 설치 가능)|
|하이브리드 앱|-네이티브 앱처럼 스토어 출시(껍데기 앱, 내용물은 웹)<br>-앱 업데이트 없이도 콘텐츠 영역 수정|- 아파치 코르도바와 같은 프렝워크의 도움을 받아 네이티브 기능을 사용하지만 순수 네이티브 앱 수준까지는 미치지 못함.<br>-웹 뷰가 그다지 빠르지 않음|
|크로스 플랫폼|- 하나의 언어로 다양한 플랫폼에 적용가능|- 새로운 언어를 익혀야함<br>- 크로스 플랫폼 도구 (리액트 네이지브, 플러터, 자마린)의 지원필요|
|PWA|- 기존 웹 앱을 PWA로 전환가능<br>- 푸시알람기능<br>- 오프라인에서도 대응 가능.<br>- 캐싱을 통한 빠른 로딩<br>- 검색엔진 노출이 쉽다.<br>- 설치 용량이 작다.|- 네이티브 앱 변환 과정이 필요.<br>- iOS에서 미지원하는 기능들이 있음|

<br>

---

# 🟣 통신

## CORS

**Cross-Origin Resource Sharing**

- 자신의 도메인과 서로 다른 도메인 간의 리소스를 공유하는 방식
- 브라우저가 제한하는 SOP(Same-Origin Policy, 동일출처정책) 기준 3개(프로토콜, 도메인, 포트) 중 하나라도 맞지 않으면 리소스 사용이 제한된다.
- @CrossOrigin 어노테이션을 이용하여 모든 도메인이나 특정 도메인에 허용을 설정할 수 있다.
   - @CrossOrigin : 모든 도메인 접근 허용
   - @CrossOrigin(origins = "http://domain1.com, http://domain2.com") : 특정 도메인 허용

## REST API

**Representational State Transfer**

- 리소스 지향 아키텍쳐
- 리소스(URI)와 HTTP 메소드(GET, POST, PUT, DELETE)를 이용해 객체화된 서비스에 접근  
- Client는 HttpURLConnection, HttpClient, OKHttp, Retrofit 등 라이브러리를 이용하여 쉽게 API에 접근할 수 있다.

## SOAP

**Simple Object Access Protocol**

- 웹 페이지를 통신할 수 있도록 설계된 최초의 표준 형식  
- XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜  
- 서비스가 있는 공간에 접근하여 자원들을 요청하는 형식  
- 서비스 지향 아키텍처를 지향함  
- 서비스 제공자는 WSDL(웹서비스 사용방법 자료. xml)만들고 UDDI에 저장한다. 그리고 허용된 사용자가 원하는 자원을 SOAP 메세지로 요청하고 응답 받는다.  

<br>

---

# 🟣 클라우드/데브옵스

## 도커
## 쿠버네티스
## CI CD
## CDN
## 클라우드 서비스 모델

<br>

---

# 🟣 운영체제와 시스템

## 프로세스 스레드
## XSS와 CSRF
## IDS IPS WAF
## 프록시 서버
## OAuth
## 암호화 복호화

<br>

---

# 🟣 프로그래밍

## 디자인패턴

🔹 싱글톤 패턴

## tdd

## rpa

## 애자일 방법론

- 신속하고 유연하게 개발하는 방법론
- 클라이언트가 원하는 요구 사항을 빠르게 피드백하며 진행하는 것
- 업무를 작게 쪼개고 중요도를 정하여 반복을 통한 업그레이드 진행


## 스택과 큐

## 예외처리


<br>

---

# 🟣 JPA



<br>

---

# 🟣 DATABASE

## 스키마
## 인덱스
## IDENTITY
## 샤딩
## ERD와 UML
## 데이터 마이닝
## 해시
## 데이터 무결성
## 프로시저
## 사용자 정의 함수
## 트리거
## 커서
## OFFSET FETCH
## 트랜젝션

<br>

# 🟣 기타 개발 상식

## ERP
